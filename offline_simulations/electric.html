<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle in Scalar Potential Field</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let animationData = null;
        let potentialField = [];
        let gradientField = [];
        let fieldGridSize = 20;
        let isPlaying = false;
        let currentFrameIndex = 0;
        let animationStartTime = 0;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
        
        function drawPotentialField() {
            const width = canvas.width;
            const height = canvas.height;
            
            if (width <= 0 || height <= 0 || !potentialField.length) return;
            
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            let minField = Infinity;
            let maxField = -Infinity;
            for (let i = 0; i < fieldGridSize; i++) {
                for (let j = 0; j < fieldGridSize; j++) {
                    minField = Math.min(minField, potentialField[i][j]);
                    maxField = Math.max(maxField, potentialField[i][j]);
                }
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const fx = (x / width) * (fieldGridSize - 1);
                    const fy = (y / height) * (fieldGridSize - 1);
                    
                    const x1 = Math.floor(fx);
                    const x2 = Math.min(x1 + 1, fieldGridSize - 1);
                    const y1 = Math.floor(fy);
                    const y2 = Math.min(y1 + 1, fieldGridSize - 1);
                    
                    const wx = fx - x1;
                    const wy = fy - y1;
                    
                    const field11 = potentialField[x1][y1];
                    const field21 = potentialField[x2][y1];
                    const field12 = potentialField[x1][y2];
                    const field22 = potentialField[x2][y2];
                    
                    const field1 = field11 * (1 - wx) + field21 * wx;
                    const field2 = field12 * (1 - wx) + field22 * wx;
                    const field = field1 * (1 - wy) + field2 * wy;
                    
                    const normalized = (field - minField) / (maxField - minField);
                    
                    const baseColor = {r: 127, g: 174, b: 186};
                    const intensity = normalized;
                    
                    const r = Math.floor(baseColor.r + (255 - baseColor.r) * intensity);
                    const g = Math.floor(baseColor.g + (255 - baseColor.g) * intensity);
                    const b = Math.floor(baseColor.b + (255 - baseColor.b) * intensity);
                    
                    const index = (y * width + x) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawParticles(particles) {
            const scaleX = canvas.width / animationData.metadata.width;
            const scaleY = canvas.height / animationData.metadata.height;
            
            ctx.fillStyle = '#4d6970';
            
            particles.forEach(particle => {
                ctx.beginPath();
                ctx.arc(
                    particle.x * scaleX, 
                    particle.y * scaleY, 
                    particle.radius * Math.min(scaleX, scaleY), 
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
            });
        }
        
        function playAnimation() {
            if (!isPlaying || !animationData) return;
            
            const currentTime = Date.now();
            const elapsed = currentTime - animationStartTime;
            
            // Find the appropriate frame for current time
            let targetFrame = Math.floor((elapsed / 1000) * animationData.metadata.fps);
            
            // Loop animation
            if (targetFrame >= animationData.frames.length) {
                animationStartTime = currentTime;
                targetFrame = 0;
                currentFrameIndex = 0;
            }
            
            // Jump to target frame if needed
            if (targetFrame > currentFrameIndex) {
                currentFrameIndex = targetFrame;
            }
            
            // Clear and render
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPotentialField();
            
            if (currentFrameIndex < animationData.frames.length) {
                const frame = animationData.frames[currentFrameIndex];
                drawParticles(frame.particles);
            }
            
            requestAnimationFrame(playAnimation);
        }
        
        function startPlayback() {
            if (!animationData) {
                console.error('No animation data available');
                return;
            }
            
            // Load field data from animation metadata
            potentialField = animationData.metadata.potentialField;
            gradientField = animationData.metadata.gradientField;
            fieldGridSize = animationData.metadata.fieldGridSize;
            
            isPlaying = true;
            animationStartTime = Date.now();
            currentFrameIndex = 0;
            console.log(`Starting playback: ${animationData.frames.length} frames`);
            playAnimation();
        }
        
        async function loadAnimationData() {
            try {
                const response = await fetch('electric_field_data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                animationData = await response.json();
                console.log(`Loaded animation data: ${animationData.frames.length} frames`);
                
                // Start playback immediately after loading
                startPlayback();
            } catch (error) {
                console.error('Error loading animation data:', error);
                console.log('Generating fallback field for demonstration...');
                
                // Generate a simple potential field for demonstration
                generateFallbackField();
            }
        }
        
        function generateFallbackField() {
            fieldGridSize = 20;
            potentialField = [];
            
            for (let i = 0; i < fieldGridSize; i++) {
                potentialField[i] = [];
                for (let j = 0; j < fieldGridSize; j++) {
                    const x = i / (fieldGridSize - 1);
                    const y = j / (fieldGridSize - 1);
                    
                    let potential = 0;
                    potential += -5.0 * Math.exp(-((x - 0.5)**2 + (y - 0.5)**2) * 8);
                    potential += -3.0 * Math.exp(-((x - 0.2)**2 + (y - 0.3)**2) * 12);
                    potential += 1.0 * Math.exp(-((x - 0.8)**2 + (y - 0.7)**2) * 15);
                    potential += 0.1 * Math.sin(x * Math.PI * 4) * Math.cos(y * Math.PI * 3);
                    
                    potentialField[i][j] = potential;
                }
            }
            
            // Just show the field
            drawPotentialField();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!isPlaying && potentialField.length) {
                drawPotentialField();
            }
        });
        
        // Initialize
        window.addEventListener('load', () => {
            resizeCanvas();
            loadAnimationData();
        });
    </script>
</body>
</html>