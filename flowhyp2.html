<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Upper Half-Plane • 45s Loop</title>
  <style>
    html, body { height: 80%; }
    body { margin: 0; background: #fff; }
    canvas { display: block; width: 90vw; height: 90vh; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    // === Canvas & world coordinates (origin at bottom-center, y up) ===
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;
    let viewScale = 0.3; // further zoomed out
    let worldW = 0, worldH = 0; // world size in CSS px

    function applyWorldTransform() {
      // map world (x,y) -> pixel: scale, flip y, translate to bottom-center
      ctx.setTransform(dpr * viewScale, 0, 0, -dpr * viewScale, canvas.width / 2, canvas.height);
    }

    function resize() {
      dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.round(innerWidth  * dpr);
      canvas.height = Math.round(innerHeight * dpr);
      worldW = canvas.width  / (dpr * viewScale);
      worldH = canvas.height / (dpr * viewScale);
      applyWorldTransform();
    }
    addEventListener('resize', resize);
    resize();

    // === Vector field on the upper half-plane (y > 0) ===
    // v(x,y) = (y^2/(x^2 + y^2)) * (2x, y^2 - x^2)
    function field(x, y) {
      // Hyperbolic gradient flow toward the ideal point 0:
      // v(x,y) = y^2 * ∇_E b_0 with b_0(x,y) = log((x^2 + y^2)/y)
      const ySafe = Math.max(y, 1e-6);
      const denom = Math.max(x * x + ySafe * ySafe, 1e-12);
      const vx = 0;
      const vy = y;
      return { x: vx, y: vy };
    }
    function fieldDir(x, y) {
      const v = field(x, y);
      const m = Math.hypot(v.x, v.y) || 1;
      return { x: v.x / m, y: v.y / m };
    }

    // === Particles ===
    class Particle {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.r = 5;
        this.trail = [];
        this.maxTrail = 300;
      }
      update(dt) {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) this.trail.shift();

        const gain = 1.0; // slower integration of the unnormalized field
        // RK4 with many substeps + y-proportional step cap
        let rem = dt;
        const MAX_H = 1/360; // ~2.78 ms per substep
        while (rem > 1e-6) {
          const h = Math.min(MAX_H, rem);
          const k1 = field(this.x, this.y);
          const k2 = field(this.x + 0.5 * h * gain * k1.x, this.y + 0.5 * h * gain * k1.y);
          const k3 = field(this.x + 0.5 * h * gain * k2.x, this.y + 0.5 * h * gain * k2.y);
          const k4 = field(this.x + h * gain * k3.x, this.y + h * gain * k3.y);
          let stepX = gain * h * (k1.x + 2*k2.x + 2*k3.x + k4.x) / 6;
          let stepY = gain * h * (k1.y + 2*k2.y + 2*k3.y + k4.y) / 6;
          const stepLen = Math.hypot(stepX, stepY);
          const cap = 0.03 * Math.max(this.y, 1e-3); // step ≤ c·y near boundary
          if (stepLen > cap) {
            const s = cap / stepLen;
            stepX *= s; stepY *= s;
          }
          this.x += stepX; this.y += stepY;
          rem -= h;
        }

        // keep if within expanded world bounds and y >= 0
        return (
          // this.x >= -worldW/2 - 250 && this.x <= worldW/2 + 250 &&
          this.y >= -50 //&& this.y <= worldH + 500
        );
      }
      draw() {
        if (this.trail.length > 1) {
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
          ctx.stroke();
        }
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // === Spawning clouds near bottom-center, slightly above x-axis ===
    let particles = [];
    const cloudTimes = [0, 12000, 24000, 36000]; // four clusters // ms
    let spawned = 0;
    let startT = 0;
    const DURATION = 45000; // ms

    function spawnCloud() {
      // Diversify cluster positions by time index
      const idx = spawned; // 0..3
      const bands = [
        { cx: 120, y: [240, 360] },
        { cx: 220, y: [320, 520] },
        { cx: 320, y: [280, 480] },
        { cx: 180, y: [380, 620] }
      ];
      const b = bands[idx % bands.length];
      const cx = (Math.random() - 0.4) * 1 * b.cx; // wider lateral spread
      const cy = b.y[0] + Math.random() * (b.y[1] - b.y[0]); // staggered height bands
      const N = 100 + Math.floor(Math.random() * 60); // 200–259
      const R = 10 + Math.random() * 30; // 30–60
      for (let i = 0; i < N; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * R;
        particles.push(new Particle(cx + Math.cos(a) * r, cy + Math.sin(a) * r));
      }
    }

    // === Rendering ===
    function clearPixel() {
      // clear in pixel space
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      applyWorldTransform();
    }

    function drawXAxis() {
      ctx.save();
      ctx.fillStyle = '#000';
      ctx.fillRect(-worldW/2, -1, worldW, 2); // thin band at y=0
      ctx.restore();
    }

    function drawFieldArrows() {
      // clip to upper half-plane y >= 0
      ctx.save();
      ctx.beginPath();
      ctx.rect(-worldW/2, 0, worldW, worldH);
      ctx.clip();

      const grid = 100; // world units
      const maxLen = 100, magScale = 0.05; // shorter arrows for a calmer field visualization // cap and scale magnitude for visibility
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = '#7FAEBA';
      ctx.fillStyle = '#7FAEBA';
      ctx.lineWidth = 3;
      for (let x = -worldW/2 + grid/2; x < worldW/2; x += grid) {
        for (let y = grid/2; y < worldH; y += grid) {
          const v = field(x, y);
          const m = Math.hypot(v.x, v.y) || 1;
          const len = Math.min(maxLen, m * magScale);
          const ux = v.x / m, uy = v.y / m;
          const tx = x + ux * len;
          const ty = y + uy * len;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(tx, ty);
          ctx.stroke();
          const ang = Math.atan2(ty - y, tx - x);
          ctx.save();
          ctx.translate(tx, ty);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-10, -10);
          ctx.lineTo(-10, 10);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawParticlesClipped(dt) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(-worldW/2, 0, worldW, worldH);
      ctx.clip();
      particles = particles.filter(p => { const alive = p.update(dt); if (alive) p.draw(); return alive; });
      ctx.restore();
    }

    let lastTS = 0;
    function loop(ts) {
      if (!lastTS) lastTS = ts;
      const dt = Math.min(0.05, (ts - lastTS) / 1000); // seconds, capped
      lastTS = ts;

      const t = Date.now() - startT;
      if (t >= DURATION) return restart();

      while (spawned < cloudTimes.length && t >= cloudTimes[spawned]) { spawnCloud(); spawned++; }

      clearPixel();
      drawXAxis();
      drawFieldArrows();
      drawParticlesClipped(dt);

      requestAnimationFrame(loop);
    }

    function restart() { particles = []; spawned = 0; startT = Date.now(); lastTS = 0; requestAnimationFrame(loop); }

    restart();
  </script>
</body>
</html>
